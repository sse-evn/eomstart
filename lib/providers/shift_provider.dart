// lib/providers/shift_provider.dart
import 'dart:async';
import 'dart:io';
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:jwt_decode/jwt_decode.dart';
import 'package:timezone/timezone.dart' as tz;
import 'package:micro_mobility_app/models/active_shift.dart' as model;
import '../models/shift_data.dart';
import '../services/api_service.dart';
import '../config/app_config.dart';

class ShiftProvider with ChangeNotifier {
  final ApiService _apiService;
  final FlutterSecureStorage _storage;
  final SharedPreferences _prefs;
  String? _token;
  model.ActiveShift? _activeShift;
  List<ShiftData> _shiftHistory = [];
  DateTime _selectedDate = _toAlmatyTime(DateTime.now());
  bool _isEndingSlot = false;
  bool _isStartingSlot = false;
  Map<String, dynamic>? _botStatsData;
  bool _isLoadingBotStats = false;
  DateTime? _lastBotStatsFetchTime;
  String? _currentUsername;
  StreamSubscription<List<ConnectivityResult>>? _connectivitySubscription;
  bool _isOnline = true;
  static const String _shiftsCacheKey = 'shifts_cache';
  static const String _lastCacheTimeKey = 'shifts_cache_time';
  bool _isLoadingActiveShift = false;
  DateTime? _lastActiveShiftFetchTime;

  // üîë –ù–û–í–´–ô –§–õ–ê–ì: –¥–∞–Ω–Ω—ã–µ —É–∂–µ –∑–∞–≥—Ä—É–∂–∞–ª–∏—Å—å —Ö–æ—Ç—è –±—ã —Ä–∞–∑
  bool _hasLoadedShifts = false;

  ShiftProvider({
    required ApiService apiService,
    required FlutterSecureStorage storage,
    required SharedPreferences prefs,
    String? initialToken,
  })  : _apiService = apiService,
        _storage = storage,
        _prefs = prefs {
    _token = initialToken;
    _initializeShiftProvider();
    _setupConnectivityListener();
  }

  static DateTime _toAlmatyTime(DateTime dateTime) {
    final almatyLocation = tz.getLocation('Asia/Almaty');
    final tzDateTime = tz.TZDateTime.from(dateTime, almatyLocation);
    return tzDateTime.toLocal();
  }

  static DateTime _nowInAlmaty() {
    final almatyLocation = tz.getLocation('Asia/Almaty');
    return tz.TZDateTime.now(almatyLocation).toLocal();
  }

  bool _isTokenValid(String token) {
    try {
      final payload = Jwt.parseJwt(token);
      final exp = payload['exp'] as int?;
      if (exp == null) return false;
      final expiryDate = DateTime.fromMillisecondsSinceEpoch(exp * 1000);
      return expiryDate.isAfter(DateTime.now());
    } catch (e) {
      return false;
    }
  }

  void _setupConnectivityListener() {
    _connectivitySubscription = Connectivity().onConnectivityChanged.listen(
      (List<ConnectivityResult> results) {
        final ConnectivityResult result =
            results.isNotEmpty ? results.last : ConnectivityResult.none;
        final bool isCurrentlyOnline = result != ConnectivityResult.none;

        if (isCurrentlyOnline && !_isOnline) {
          // üî• –ò–ó–ú–ï–ù–ï–ù–û: –Ω–µ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏, –µ—Å–ª–∏ —É–∂–µ –∑–∞–≥—Ä—É–∂–∞–ª–∏
          if (!_hasLoadedShifts && _token != null) {
            WidgetsBinding.instance.addPostFrameCallback((_) {
              loadShifts();
            });
          }
        }

        _isOnline = isCurrentlyOnline;
        WidgetsBinding.instance.addPostFrameCallback((_) {
          notifyListeners();
        });
      },
      onError: (error) {
        debugPrint('‚ùå –û—à–∏–±–∫–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Å–µ—Ç–∏: $error');
      },
    );
  }

  Future<void> _saveToCache() async {
    try {
      final data = {
        'shifts': _shiftHistory.map((s) => s.toJson()).toList(),
        'activeShift': _activeShift?.toJson(),
        'username': _currentUsername,
        'botStatsData': _botStatsData,
        'timestamp': DateTime.now().toIso8601String(),
      };
      await _prefs.setString(_shiftsCacheKey, jsonEncode(data));
    } catch (e) {
      debugPrint('‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ –∫—ç—à: $e');
    }
  }

  Future<void> loadFromCache() async {
    try {
      final cached = _prefs.getString(_shiftsCacheKey);
      if (cached == null) return;
      final data = jsonDecode(cached) as Map<String, dynamic>;
      final timestamp = DateTime.parse(data['timestamp']);
      if (DateTime.now().difference(timestamp) > const Duration(hours: 24)) {
        await _prefs.remove(_shiftsCacheKey);
        return;
      }
      final List<dynamic> shifts = data['shifts'];
      _shiftHistory = shifts.map((json) => ShiftData.fromJson(json)).toList();
      final activeShiftData = data['activeShift'];
      _activeShift = activeShiftData != null
          ? model.ActiveShift.fromJson(activeShiftData)
          : null;
      _currentUsername = data['username'] as String?;
      _botStatsData = data['botStatsData'] as Map<String, dynamic>?;
      WidgetsBinding.instance.addPostFrameCallback((_) {
        notifyListeners();
      });
    } catch (e) {
      debugPrint('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑ –∫—ç—à–∞: $e');
    }
  }

  model.ActiveShift? get activeShift => _activeShift;
  List<ShiftData> get shiftHistory => _shiftHistory;
  List<ShiftData> get activeShifts =>
      _shiftHistory.where((shift) => shift.isActive).toList();
  DateTime get selectedDate => _selectedDate;
  Map<String, dynamic>? get botStatsData => _botStatsData;
  bool get isLoadingBotStats => _isLoadingBotStats;
  String? get currentUsername => _currentUsername;

  String get formattedWorkTime {
    if (_activeShift?.startTime == null) return '0—á 0–º–∏–Ω 0—Å';
    final now = _nowInAlmaty();
    final duration = now.difference(_activeShift!.startTime!);
    final hours = duration.inHours;
    final minutes = duration.inMinutes % 60;
    final seconds = duration.inSeconds % 60;
    return '${hours}—á ${minutes}–º–∏–Ω ${seconds}—Å';
  }

  Future<void> setToken(String token) async {
    _token = token;
    await _storage.write(key: 'jwt_token', value: token);
    await _initializeShiftProvider();
  }

  Future<void> _initializeShiftProvider() async {
    if (_token == null) {
      _token = await _storage.read(key: 'jwt_token');
    }
    if (_token != null && !_isTokenValid(_token!)) {
      debugPrint('üîê –¢–æ–∫–µ–Ω –ø—Ä–æ—Å—Ä–æ—á–µ–Ω. –í—ã–ø–æ–ª–Ω—è–µ–º –≤—ã—Ö–æ–¥...');
      await logout();
      return;
    }
    await loadFromCache();
    if (_isOnline && _token != null && !_hasLoadedShifts) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        loadShifts();
      });
    }
  }

  Future<model.ActiveShift?> getActiveShift() async {
    if (_token == null || _isLoadingActiveShift) return _activeShift;
    if (_lastActiveShiftFetchTime != null) {
      final now = DateTime.now();
      final difference = now.difference(_lastActiveShiftFetchTime!);
      if (difference < const Duration(seconds: 30) && _activeShift != null) {
        debugPrint('ShiftProvider: getActiveShift skipped (cache hit).');
        return _activeShift;
      }
    }
    try {
      _isLoadingActiveShift = true;
      final response =
          await _retryApiCall(() => _apiService.getActiveShift(_token!));

      if (response == null ||
          response.toString() == 'null' ||
          response.toString() == '[]' ||
          response.toString() == '{}') {
        _activeShift = null;
      } else {
        _activeShift = response;
      }

      _lastActiveShiftFetchTime = DateTime.now();
      if (_activeShift != null) {
        _currentUsername = _activeShift!.username;
      } else {
        _currentUsername = null;
      }
      await _saveToCache();
      return _activeShift;
    } catch (e) {
      debugPrint('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∞–∫—Ç–∏–≤–Ω–æ–π —Å–º–µ–Ω—ã: $e');
      _activeShift = null;
      return _activeShift;
    } finally {
      _isLoadingActiveShift = false;
      WidgetsBinding.instance.addPostFrameCallback((_) {
        notifyListeners();
      });
    }
  }

  Future<T> _retryApiCall<T>(Future<T> Function() apiCall) async {
    const maxRetries = 3;
    const retryDelay = Duration(seconds: 2);
    for (var i = 0; i < maxRetries; i++) {
      try {
        return await apiCall();
      } catch (e) {
        if (e.toString().contains('502') && i < maxRetries - 1) {
          await Future.delayed(retryDelay);
          continue;
        }
        rethrow;
      }
    }
    throw Exception('API call failed after $maxRetries retries');
  }

  // üî• –û–°–ù–û–í–ù–û–ô –ú–ï–¢–û–î: loadShifts
  Future<void> loadShifts() async {
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–ª–∞–≥, —á—Ç–æ –∑–∞–≥—Ä—É–∑–∫–∞ –Ω–∞—á–∞–ª–∞—Å—å
    // (–¥–∞–∂–µ –µ—Å–ª–∏ –±—É–¥–µ—Ç –æ—à–∏–±–∫–∞ ‚Äî —Å—á–∏—Ç–∞–µ–º, —á—Ç–æ "–ø—ã—Ç–∞–ª–∏—Å—å")
    final isFirstLoad = !_hasLoadedShifts;
    _hasLoadedShifts = true;

    if (_token == null) {
      _shiftHistory = [];
      _activeShift = null;
      _currentUsername = null;
      WidgetsBinding.instance.addPostFrameCallback((_) {
        notifyListeners();
      });
      return;
    }
    if (!_isTokenValid(_token!)) {
      debugPrint('üîê –¢–æ–∫–µ–Ω –∏—Å—Ç—ë–∫. –í—ã—Ö–æ–¥...');
      await logout();
      return;
    }
    try {
      final dynamic shiftsData =
          await _retryApiCall(() => _apiService.getShifts(_token!));
      if (shiftsData is List) {
        _shiftHistory = shiftsData
            .whereType<Map<String, dynamic>>()
            .map((json) => ShiftData.fromJson(json))
            .toList();
      } else {
        _shiftHistory = [];
      }
      await getActiveShift();
      await _saveToCache();
      WidgetsBinding.instance.addPostFrameCallback((_) {
        notifyListeners();
      });
    } catch (e) {
      debugPrint('ShiftProvider.loadShifts error: $e');
      // –ï—Å–ª–∏ –ø–µ—Ä–≤–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –∏ –Ω–µ—Ç –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞ ‚Äî –≥—Ä—É–∑–∏–º –∏–∑ –∫—ç—à–∞
      if (isFirstLoad && !_isOnline) {
        await loadFromCache();
      } else {
        // –ò–Ω–∞—á–µ ‚Äî —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ (–æ—à–∏–±–∫–∞ —Å–µ—Ç–∏/—Å–µ—Ä–≤–µ—Ä–∞)
        _shiftHistory = [];
        _activeShift = null;
        _currentUsername = null;
      }
      WidgetsBinding.instance.addPostFrameCallback((_) {
        notifyListeners();
      });
    }
  }

  void selectDate(DateTime date) {
    _selectedDate = _toAlmatyTime(DateTime(date.year, date.month, date.day));
    WidgetsBinding.instance.addPostFrameCallback((_) {
      notifyListeners();
    });
  }

  Future<void> startSlot({
    required String slotTimeRange,
    required String position,
    required String zone,
    required XFile selfie,
  }) async {
    if (_isStartingSlot || _activeShift != null || _token == null) return;
    final File imageFile = File(selfie.path);
    _isStartingSlot = true;
    WidgetsBinding.instance.addPostFrameCallback((_) {
      notifyListeners();
    });
    try {
      await _retryApiCall(() => _apiService.startSlot(
            token: _token!,
            slotTimeRange: slotTimeRange,
            position: position,
            zone: zone,
            selfieImage: imageFile,
          ));
      debugPrint('‚úÖ –°–º–µ–Ω–∞ –Ω–∞—á–∞—Ç–∞');
      await loadShifts(); // –ó–¥–µ—Å—å —É–º–µ—Å—Ç–Ω–æ ‚Äî –¥–µ–π—Å—Ç–≤–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    } catch (e) {
      debugPrint('‚ùå –û—à–∏–±–∫–∞ —Å—Ç–∞—Ä—Ç–∞ —Å–º–µ–Ω—ã: $e');
      rethrow;
    } finally {
      _isStartingSlot = false;
      WidgetsBinding.instance.addPostFrameCallback((_) {
        notifyListeners();
      });
    }
  }

  Future<void> endSlot() async {
    if (_isEndingSlot || _token == null || _activeShift == null) return;
    _isEndingSlot = true;
    WidgetsBinding.instance.addPostFrameCallback((_) {
      notifyListeners();
    });
    try {
      await _retryApiCall(() => _apiService.endSlot(_token!));
      debugPrint('‚úÖ –°–º–µ–Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞');
      _lastActiveShiftFetchTime = null;
      _activeShift = null;
      _currentUsername = null;
      await loadShifts(); // –£–º–µ—Å—Ç–Ω–æ ‚Äî –¥–µ–π—Å—Ç–≤–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    } catch (e) {
      debugPrint('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Å–º–µ–Ω—ã: $e');
      await loadShifts();
      rethrow;
    } finally {
      _isEndingSlot = false;
      WidgetsBinding.instance.addPostFrameCallback((_) {
        notifyListeners();
      });
    }
  }

  Future<void> fetchBotStats() async {
    if (_isLoadingBotStats) {
      debugPrint('ShiftProvider: Bot stats fetch already in progress.');
      return;
    }
    if (_lastBotStatsFetchTime != null) {
      final now = DateTime.now();
      final difference = now.difference(_lastBotStatsFetchTime!);
      if (difference < const Duration(seconds: 30)) {
        debugPrint('ShiftProvider: Bot stats fetch skipped (cache hit).');
        if (_botStatsData != null) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            notifyListeners();
          });
        }
        return;
      }
    }
    if (_token == null) {
      debugPrint('ShiftProvider: Cannot fetch bot stats, no token.');
      _botStatsData = null;
      WidgetsBinding.instance.addPostFrameCallback((_) {
        notifyListeners();
      });
      return;
    }
    _isLoadingBotStats = true;
    WidgetsBinding.instance.addPostFrameCallback((_) {
      notifyListeners();
    });
    try {
      debugPrint('ShiftProvider: Fetching bot stats...');
      final stats = await _retryApiCall(
          () => _apiService.getScooterStatsForShift(_token!));
      _botStatsData = stats;
      _lastBotStatsFetchTime = DateTime.now();
      debugPrint('‚úÖ Bot stats fetched successfully.');
      await _saveToCache();
    } catch (e) {
      debugPrint('‚ùå ShiftProvider.fetchBotStats error: $e');
    } finally {
      _isLoadingBotStats = false;
      WidgetsBinding.instance.addPostFrameCallback((_) {
        notifyListeners();
      });
    }
  }

  Future<void> logout() async {
    _token = null;
    _activeShift = null;
    _currentUsername = null;
    _botStatsData = null;
    _hasLoadedShifts = false; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ
    await _storage.delete(key: 'jwt_token');
    await _prefs.remove(_shiftsCacheKey);
    WidgetsBinding.instance.addPostFrameCallback((_) {
      notifyListeners();
    });
  }

  @override
  void dispose() {
    _connectivitySubscription?.cancel();
    super.dispose();
  }
}
